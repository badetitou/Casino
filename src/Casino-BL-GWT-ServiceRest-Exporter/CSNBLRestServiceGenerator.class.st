"
""aCasinoModel""
gwtModel 
	allCSNService do: [ :service | CSNBLRestServiceGenerator export: service ]
"
Class {
	#name : #CSNBLRestServiceGenerator,
	#superclass : #FAMIX2JavaVisitor,
	#instVars : [
		'service',
		'rootNamespace'
	],
	#category : #'Casino-BL-GWT-ServiceRest-Exporter'
}

{ #category : #actions }
CSNBLRestServiceGenerator class >> export: service [
	self new service: service; export
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAnnotation [
	(currentStream << '@Path("' << service targetPoint asKebabCase)
		<< '")';
		crlf
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAnnotationForServiceAPI: aServiceAPI [
	(self << '@Path("' <<< aServiceAPI name asKebabCase)
		<<< '")';
		crlf.
	self addRESTTypeAnnotationFor: aServiceAPI.
	self
		<< '@Produces(MediaType.APPLICATION_JSON)';
		crlf.
	aServiceAPI isGET
		ifFalse: [ self
				<< '@Consumes(MediaType.MULTIPART_FORM_DATA)';
				crlf ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAuthors [
	self
		<< '/**';
		crlf;
		<< ' * Generated by Casino';
		crlf;
		<< ' *';
		crlf;
		<< ' * @author Anas Shatnawi';
		crlf;
		<< ' * @author BenoÃ®t Verhaeghe';
		crlf;
		<< ' * @author Abderrahmane Seriai';
		crlf;
		<< '**/'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addRESTTypeAnnotationFor: aServiceAPI [
	aServiceAPI isDELETE
		ifTrue: [ self << '@POST' ]
		ifFalse: [ aServiceAPI isGET
				ifTrue: [ self << '@GET' ]
				ifFalse: [ self << '@POST' ] ].
	self crlf
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> additionalExceptionFor: aServiceAPI [
	^ (aServiceAPI parameters anySatisfy: [ :parameter | parameter dataType isDictionaryType ])
		ifTrue: [ {'JsonParseException' . 'JsonMappingException' . 'IOException'} ]
		ifFalse: [ {} ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertBusinessType: serviceParameter [
	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	(self << serviceParameter name)
		<<< 'Json.setMediaType(MediaType.APPLICATION_JSON_TYPE);';
		crlf.
	serviceParameter source declaredType ifNotNil: [ 
	self << serviceParameter source declaredType name <<< ' ' <<< serviceParameter name <<< ' = ' <<< serviceParameter name <<< 'Json.getValueAs('
		<<< serviceParameter source declaredType name <<< '.class);' ] ifNil: [  self << '// FIX: ' <<< serviceParameter name ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertCollectionType: serviceParameter [
	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	self indent.
	serviceParameter source declaredType accept: self.
	(self <<< ' ' <<< serviceParameter name)
		<<< ' = new ArrayList<>();';
		crlf.
	(self << 'for (FormDataBodyPart formDataBodyPart: ' <<< serviceParameter name)
		<<< 'Json) {';
		crlf.
	self indentPlus.
	self
		<< 'formDataBodyPart.setMediaType(MediaType.APPLICATION_JSON_TYPE);';
		crlf.
	(self << serviceParameter name <<< '.add(formDataBodyPart.getValueAs(' <<< serviceParameter source declaredType arguments anyOne name)
		<<< '.class));';
		crlf.
	self indentMinus.
	^ self << '}'
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertDictionaryType: serviceParameter [
	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	self indent.
	serviceParameter source declaredType accept: self.
	self <<< ' ' <<< serviceParameter name <<< ' = new ObjectMapper().readValue(' <<< serviceParameter name <<< 'Json, Map.class);'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> createNamespaceFolderForClass: class [
	self visitNamespace: (class atScope: FamixTPackage) anyOne
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> defaultRootNamespace [
	^ 'fr/bl/server/omaje/ws/rest'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> export [
	self rootFolder ensureCreateDirectory.
	service ifNil: [ self error ].
	service source ifNotNil: [ :source | self createNamespaceFolderForClass: source ].
	self visit: service source
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> initialize [
	super initialize.
	self rootFolder: FileSystem disk workingDirectory asFileReference / self rootNamespace
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAdditionalExceptionFor: aServiceAPI [
	(aServiceAPI parameters anySatisfy: [ :parameter | parameter dataType isDictionaryType ])
		ifTrue: [ self <<< ', JsonParseException, JsonMappingException, IOException' ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAttributeOf: aMethod ofServiceApi: aServiceAPI [
	(aServiceAPI parameters sorted: [ :p :p2 | p source sourceAnchor startPos < p2 source sourceAnchor startPos ])
		do: [ :parameter | 
			aServiceAPI isGET
				ifTrue: [ self <<< '@QueryParam("' <<< parameter name asKebabCase <<< '") ' ]
				ifFalse: [ self <<< '@FormDataParam("' <<< parameter name asKebabCase <<< '") ' ].
			self visitServiceAPIParameter: parameter ]
		separatedBy: [ self <<< ', ' ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> printConvertParametersOf: aServiceAPI [
	self crlf.
	aServiceAPI parameters
		do: [ :serviceParameter | 
			serviceParameter dataType isCollectionType
				ifTrue: [ self convertCollectionType: serviceParameter.
					self crlf ]
				ifFalse: [ serviceParameter dataType isDictionaryType
						ifTrue: [ self convertDictionaryType: serviceParameter.
							self crlf ]
						ifFalse: [ (serviceParameter dataType isBusinessType or: [ serviceParameter dataType isPrimitive not ])
								ifTrue: [ self convertBusinessType: serviceParameter.
									self crlf ] ] ] ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printImports: aClass [
	| declaredTypes annotationTypes |
	declaredTypes := (self extractDeclaredTypesFor: aClass) asSet.
	aClass subclassHierarchyGroup do: [ :subClass | declaredTypes addAll: (self extractDeclaredTypesFor: subClass) ].
	self printImportsDeclaredTypes: declaredTypes. 
	"fetching annotation imports"
	annotationTypes := (self extractAnnotationTypesFor: aClass) asSet.
	aClass subclassHierarchyGroup do: [ :subClass | annotationTypes addAll: ((self extractAnnotationTypesFor: subClass)) ].
	self printImportsAnnotationTypes: annotationTypes.
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printRESTImports [
	self << 'import javax.ws.rs.Consumes;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.DELETE;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;

import org.glassfish.jersey.media.multipart.FormDataParam;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;

import org.springframework.beans.factory.annotation.Autowired;

import org.codehaus.jackson.JsonParseException;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import java.io.IOException;
'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printSetterOf: aAttribute [

	self << 'public void set' <<< aAttribute name capitalized <<< ' ('.
	self printDeclaredType: aAttribute declaredType.
	(self <<< ' ' <<< aAttribute name)
		<<< ') {';
		crlf.
	self
		indentPlus;
		indent.
	(self <<< 'this.' <<< aAttribute name <<< ' = ' <<< aAttribute name)
		<<< ';';
		crlf.
	self
		indentMinus;
		<< '}'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> reset [
	super reset.
	self initialize
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> rootNamespace [
	^ rootNamespace ifNil: [ rootNamespace := self defaultRootNamespace ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> rootNamespace: aNamespace [
	rootNamespace := aNamespace
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> service: aService [
	service := aService 
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitAttribute: aAttribute [

	((aAttribute annotationInstances anySatisfy: [ :ann | 
		  ann name beginsWith: '@Autowired' ]) or: [ 
		 aAttribute declaredType isNil or: [ 
			 aAttribute declaredType isPrimitiveType or: [ aAttribute isClassSide ] ] ]) 
		ifFalse: [ 
			self
				<< '@Autowired';
				crlf ].
	super visitAttribute: aAttribute
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitClass: aClass [

	| file |
	file := self rootFolder / ('Rest' , (aClass name removePrefix: 'IGwt') , '.java').
	file deleteIfAbsent: [  ].
	file writeStreamDo: [ :stream | 
		currentStream := stream.
		"Printing class package and imports if the class is not an inner class"
		aClass typeContainer isPackage ifTrue: [ 
			self << 'package '.
			aClass typeContainer fullNameLowerCasePrintOn: currentStream fromRoot: (self rootNamespace copyReplaceAll: '/' with: '.').
			self
				<<< ';';
				crlf;
				crlf.
			self printImports: aClass.
			self crlf.
			self printRESTImports.
			self
				crlf;
				crlf ].
		"Printing class annotations"
		self addAuthors.
		self crlf.
		self addAnnotation.
		"Printing Class declaration"
		currentStream << 'public '.
		currentStream << 'class '.
		currentStream << 'Rest' << (aClass name removePrefix: 'IGwt').
		currentStream
			<< ' {';
			<< String crlf.
		"Printing Attributs"
		tabs := tabs + 1.
		(aClass attributes , aClass subclassHierarchyGroup collect: #attributes) flattened do: [ :attribute | 
			self clone visit: attribute.
			self
				crlf;
				crlf ].
		"Closing Class"
		service actions do: [ :action | self visitServiceAPI: action ] separatedBy: [ 
			self
				crlf;
				crlf ].
		currentStream
			<< String crlf;
			<< '}' ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitNamespace: aNamespace [
	aNamespace name = '<Default Package>' ifTrue: [ ^ self ].
	((aNamespace allParents reject: [ :p | p name = 'remote' ]) reverse allButFirst: 4)
		do: [ :namespace | 
			self rootFolder: self rootFolder / namespace name asLowercase.
			self rootFolder ensureCreateDirectory ].
	aNamespace name = 'remote'
		ifFalse: [ self rootFolder: self rootFolder / aNamespace name asLowercase.
			self rootFolder ensureCreateDirectory ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitServiceAPI: aServiceAPI [
	| aMethod |
	aServiceAPI name record.
	aMethod := aServiceAPI source.
	aMethod isStub ifTrue: [ ^ self ].
	"Printing method annotations"
	aMethod comments do: [ :comment | self << comment sourceText ] separatedBy: [ self crlf ].
	aMethod methodsOverriding do: [ :methodOverriding | methodOverriding comments do: [ :comment | self << comment sourceText ] ] separatedBy: [ self crlf ].
	self crlf.
	self addAnnotationForServiceAPI: aServiceAPI.
	"Printing modifiers of method ex: static,public/private/protected"
	self indent.
	(aMethod cacheAt: #modifiers ifAbsent: [( aMethod respondsTo:  #modifiers) ifTrue: [ aMethod modifiers ] ifFalse: [ {  } ] ])
		ifNotEmptyDo: [ :modifier | 
			self
				<<< modifier;
				space ]
		ifEmpty: [ self <<< 'public'; space ].
	"Printing return type for method"
	aMethod declaredType
		ifNotNil: [ :declaredType | 
			self printDeclaredType: declaredType.
			currentStream << String space ].
	"Printing name + parameters of method"
	(aMethod name = '<Initializer>' or: [ aMethod isInitializer and: [ aMethod isConstructor not ] ])
		ifFalse: [ self
				<<< aMethod name;
				<<< '('.
			self printAttributeOf: aMethod ofServiceApi: aServiceAPI.
			self <<< ')' ]
		ifTrue: [ self << 'static' ].
	"print exception"
	(((aMethod withMethodsOverriding collect: [ :m | m thrownExceptions collect: #exceptionClass ]) flattened asSet asOrderedCollection sorted: #name ascending)
		collect: #name) , (self additionalExceptionFor: aServiceAPI)
		ifNotEmpty: [ :exceptionsName | 
			self <<< ' throws '.
			exceptionsName do: [ :exceptionName | self <<< exceptionName ] separatedBy: [ self <<< ', ' ] ].

	"Printing body of method if class is not abstract or an interface"
	currentStream
		<< ' {';
		<< String crlf.
	self indentPlus.
	self printConvertParametersOf: aServiceAPI.
	aMethod methodsOverriding ifNotEmpty: [ :methods | methods do: [ :methodOverriding | self << methodOverriding bodySourceText ] separatedBy: [ self crlf ] ]  ifEmpty: [ self << '// Error body not found ' ].
	self
		crlf;
		indentMinus;
		<< '}'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitServiceAPIParameter: parameter [
	parameter dataType isDictionaryType
		ifTrue: [ self <<< 'String ' <<< parameter name ]
		ifFalse: [ parameter dataType isCollectionType
				ifTrue: [ self <<< 'List<FormDataBodyPart> ' <<< parameter name ]
				ifFalse: [ (parameter dataType isBusinessType or: [ parameter dataType isPrimitive not ])
						ifTrue: [ self <<< 'FormDataBodyPart ' <<< parameter name ]
						ifFalse: [ self visitParameter: parameter source ] ] ].
	parameter dataType isPrimitive not ifTrue: [ self <<< 'Json' ]
]
