"
```
restServiceExporter := CSNBLRestServiceGenerator new.
restServiceExporter rootFolder: ('my/root/fr/local/package/path' asFileReference).
restServiceExporter rootNamespace: 'fr/local/package/path'.
gwtModel allCSNService do: [ :service | restServiceExporter service: service; export ].
```
"
Class {
	#name : #CSNBLRestServiceGenerator,
	#superclass : #FAMIX2JavaVisitor,
	#instVars : [
		'service',
		'rootNamespace'
	],
	#category : #'Casino-BL-GWT-ServiceRest-Exporter'
}

{ #category : #actions }
CSNBLRestServiceGenerator class >> export: service [
	self new service: service; export
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAnnotation [

	currentStream
		<< '@Component';
		crlf;
		<< '@ApplicationPath("/rest-csn")';
		crlf.
	(currentStream << '@Path("' << service targetPoint)
		<< '")';
		crlf
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAnnotationForServiceAPI: aServiceAPI [
	(self << '@Path("' <<< aServiceAPI uniqueName)
		<<< '")';
		crlf.
	self addRESTTypeAnnotationFor: aServiceAPI.
	self
		<< '@Produces(MediaType.APPLICATION_JSON)';
		crlf.
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAuthors [
	self
		<< '/**';
		crlf;
		<< ' * Generated by Casino';
		crlf;
		<< '**/'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addRESTTypeAnnotationFor: aServiceAPI [

	"aServiceAPI isDELETE
		ifTrue: [ self << ''@POST'' ]
		ifFalse: [ aServiceAPI isGET
				ifTrue: [ self << ''@GET'' ]
				ifFalse: [ self << ''@POST'' ] ]."

	self << '@POST'.
	self crlf
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> additionalExceptionFor: aServiceAPI [

	^ { 'JsonProcessingException' } "(aServiceAPI parameters anySatisfy: [ :parameter | parameter dataType isDictionaryType ])
		ifTrue: [ {'JsonParseException' . 'JsonMappingException' . 'IOException'} ]
		ifFalse: [ {} ]"
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertBusinessType: serviceParameter [

	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	serviceParameter source declaredType
		ifNotNil: [ 
			self << serviceParameter source declaredType name <<< ' '
			<<< serviceParameter name <<< ' = '
			<<< 'CSNRestful.MAPPER.treeToValue(body.get("'
			<<< serviceParameter name <<< '"), '
			<<< serviceParameter source declaredType name <<< '.class);' ]
		ifNil: [ self << '// FIX: ' <<< serviceParameter name ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertCollectionType: serviceParameter [

	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	self indent.
	self printDeclaredType: serviceParameter source declaredType.
	self <<< ' ' <<< serviceParameter name
	<<< ' = CSNRestful.MAPPER.treeToValue(body.get("'
	<<< serviceParameter name <<< '"), '.
	self <<< (serviceParameter source declaredType name = 'List'
		 ifTrue: [ 'ArrayList' ]
		 ifFalse: [ serviceParameter source declaredType name ]).
	self <<< '.class);'
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertDictionaryType: serviceParameter [

	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	self indent.
	serviceParameter dataType writeJavaBusinessTypeOn: self.
	self <<< ' ' <<< serviceParameter name
	<<< ' = CSNRestful.MAPPER.treeToValue(body.get("'
	<<< serviceParameter name <<< '"), '.
	self <<< serviceParameter source declaredType name.
	self <<< '.class);'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> createNamespaceFolderForClass: class [
	self visitNamespace: (class atScope: FamixTPackage) anyOne
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> defaultRootNamespace [
	^ 'fr/bl/server/omaje/ws/rest'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> export [
	| exporter |
	exporter := self clone.
	self rootFolder ensureCreateDirectory.
	service ifNil: [ self error ].
	service source ifNotNil: [ :source | exporter createNamespaceFolderForClass: source ].
	exporter visit: service source
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> initialize [
	super initialize.
	self rootFolder: FileSystem disk workingDirectory asFileReference / self rootNamespace
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAPIParameter [
	self <<< '@RequestBody ObjectNode body'
	"parameter dataType isDictionaryType
		ifTrue: [ self <<< 'String ' <<< parameter name ]
		ifFalse: [ parameter dataType isCollectionType
				ifTrue: [ self <<< 'List<FormDataBodyPart> ' <<< parameter name ]
				ifFalse: [ (parameter dataType isBusinessType or: [ parameter dataType isPrimitive not ])
						ifTrue: [ self <<< 'FormDataBodyPart ' <<< parameter name ]
						ifFalse: [ self visitParameter: parameter source ] ] ].
	parameter dataType isPrimitive not ifTrue: [ self <<< 'Json' ]"
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAdditionalExceptionFor: aServiceAPI [
	(aServiceAPI parameters anySatisfy: [ :parameter | parameter dataType isDictionaryType ])
		ifTrue: [ self <<< ', JsonParseException, JsonMappingException, IOException' ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAdditionalMethodsFor: aClass [
	"can be override to add additional methods"
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAttributeOf: aMethod ofServiceApi: aServiceAPI [
	(aServiceAPI parameters sorted: [ :p :p2 | p source sourceAnchor startPos < p2 source sourceAnchor startPos ])
		do: [ :parameter | 
			aServiceAPI isGET
				ifTrue: [ self <<< '@QueryParam("' <<< parameter name asKebabCase <<< '") ' ]
				ifFalse: [ self <<< '@FormDataParam("' <<< parameter name asKebabCase <<< '") ' ].
			self visitServiceAPIParameter: parameter ]
		separatedBy: [ self <<< ', ' ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> printConvertParametersOf: aServiceAPI [

	self crlf.
	aServiceAPI parameters do: [ :serviceParameter | 
		serviceParameter dataType isCollectionType
			ifTrue: [ self convertCollectionType: serviceParameter ]
			ifFalse: [ 
				serviceParameter dataType isDictionaryType
					ifTrue: [ self convertDictionaryType: serviceParameter ]
					ifFalse: [ self convertBusinessType: serviceParameter ] ].
		self crlf ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printDefaultImport [

	"can be override"
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printImports: aClass [

	| declaredTypes annotationTypes |
	declaredTypes := (self extractDeclaredTypesFor: aClass) asSet.
	aClass subclassHierarchyGroup do: [ :subClass | 
		declaredTypes addAll: (self extractDeclaredTypesFor: subClass) ].
	service parentService ifNotNil: [ :aParentService | 
		declaredTypes add: aParentService source ].
	self printImportsDeclaredTypes: declaredTypes asSet.
	"fetching annotation imports"
	self
		crlf;
		<< '// Annotation import';
		crlf.
	annotationTypes := (self extractAnnotationTypesFor: aClass) asSet.
	aClass subclassHierarchyGroup do: [ :subClass | 
		annotationTypes addAll: (self extractAnnotationTypesFor: subClass) ].
	self printImportsAnnotationTypes: annotationTypes.
	"default import"
	self
		crlf;
		<< '// Default import';
		crlf.

	self
		<< 'import java.util.ArrayList;';
		crlf.
	self printDefaultImport
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printRESTImports [
	self << 'import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.DELETE;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.ApplicationPath;

import fr.bl.server.gf.rest.CSNRestful;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;
'
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printSetterOf: aAttribute [

	self << 'public void set' <<< aAttribute name capitalized <<< ' ('.
	self printDeclaredType: aAttribute declaredType.
	(self <<< ' ' <<< aAttribute name)
		<<< ') {';
		crlf.
	self
		indentPlus;
		indent.
	(self <<< 'this.' <<< aAttribute name <<< ' = ' <<< aAttribute name)
		<<< ';';
		crlf.
	self
		indentMinus;
		<< '}'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> reset [
	super reset.
	self initialize
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> rootNamespace [
	^ rootNamespace ifNil: [ rootNamespace := self defaultRootNamespace ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> rootNamespace: aNamespace [
	rootNamespace := aNamespace
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> service: aService [
	service := aService 
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitAttribute: aAttribute [

	((aAttribute annotationInstances anySatisfy: [ :ann | 
		  ann name beginsWith: '@Autowired' ]) or: [ 
		 aAttribute declaredType isNil or: [ 
			 aAttribute declaredType isPrimitiveType or: [ aAttribute isClassSide ] ] ]) 
		ifFalse: [ 
			self
				<< '@Autowired';
				crlf ].
	super visitAttribute: aAttribute
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitClass: aClass [

	| file |
	file := self rootFolder
	        / ('Rest' , (aClass name removePrefix: 'Gwt') , '.java').
	file deleteIfAbsent: [  ].
	file writeStreamDo: [ :stream | 
		currentStream := stream.
		"Printing class package and imports if the class is not an inner class"
		aClass typeContainer isPackage ifTrue: [ 
			self << 'package '.
			aClass typeContainer
				fullNameLowerCasePrintOn: currentStream
				fromRoot: ((self rootNamespace copyReplaceAll: '/' with: '.')
						 copyReplaceAll: '\'
						 with: '.').
			self
				<<< ';';
				crlf;
				crlf.
			self printImports: aClass.
			self crlf.
			self printRESTImports.
			self
				crlf;
				crlf ].
		"Printing class annotations"
		self addAuthors.
		self crlf.
		self addAnnotation.
		"Printing Class declaration"
		currentStream << 'public '.
		currentStream << 'class '.
		currentStream << 'Rest' << (aClass name removePrefix: 'Gwt').
		service parentService ifNotNil: [ :parentService | 
			self <<< ' extends ' <<< service parentService source name ].
		currentStream
			<< ' {';
			<< String crlf.
		"Printing Attributs"
		self indentPlus.

		(aClass attributes
		 , (aClass subclassHierarchyGroup collect: #attributes)) flattened 
			do: [ :attribute | 
				self clone visit: attribute.
				self
					crlf;
					crlf ].
		"Closing Class"
		service actions
			do: [ :action | self visitServiceAPI: action ]
			separatedBy: [ 
				self
					crlf;
					crlf ].
		self printAdditionalMethodsFor: aClass.
		currentStream
			<< String crlf;
			<< '}' ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitNamespace: aNamespace [
	aNamespace name = '<Default Package>' ifTrue: [ ^ self ].
	((aNamespace allParents reject: [ :p | p name = 'remote' ]) reverse allButFirst: 4)
		do: [ :namespace | 
			self rootFolder: self rootFolder / namespace name asLowercase.
			self rootFolder ensureCreateDirectory ].
	aNamespace name = 'remote'
		ifFalse: [ self rootFolder: self rootFolder / aNamespace name asLowercase.
			self rootFolder ensureCreateDirectory ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitServiceAPI: aServiceAPI [

	| aMethod |
	aServiceAPI name record.
	aMethod := aServiceAPI source.
	aMethod isStub ifTrue: [ ^ self ].
	"Printing method annotations"
	aMethod comments
		do: [ :comment | self << comment sourceText ]
		separatedBy: [ self crlf ].
	aMethod withMethodsOverriding
		do: [ :methodOverriding | 
			methodOverriding comments do: [ :comment | 
				self << comment sourceText ] ]
		separatedBy: [ self crlf ].
	self crlf.
	self addAnnotationForServiceAPI: aServiceAPI.
	"Printing modifiers of method ex: static,public/private/protected"
	self indent.
	(aMethod cacheAt: #modifiers ifAbsent: [ 
		 (aMethod respondsTo: #modifiers)
			 ifTrue: [ aMethod modifiers ]
			 ifFalse: [ {  } ] ])
		ifNotEmptyDo: [ :modifier | 
			self
				<<< modifier;
				space ]
		ifEmpty: [ 
			self
				<<< 'public';
				space ].
	"Printing return type for method"
	aMethod declaredType ifNotNil: [ :declaredType | 
		aServiceAPI dataType writeJavaBusinessTypeOn: self.
		currentStream << String space ].
	"Printing name + parameters of method"
	(aMethod name = '<Initializer>' or: [ 
		 aMethod isInitializer and: [ aMethod isConstructor not ] ])
		ifFalse: [ 
			self
				<<< aServiceAPI uniqueName;
				<<< '('.
			self printAPIParameter.
			"self printAttributeOf: aMethod ofServiceApi: aServiceAPI."
			self <<< ')' ]
		ifTrue: [ self << 'static' ].
	"print exception"
	(((aMethod withMethodsOverriding collect: [ :m | 
		   m thrownExceptions , m declaredExceptions collect:
			   #exceptionClass ]) flattened asSet asOrderedCollection sorted:
		  #name ascending) collect: #name)
	, (self additionalExceptionFor: aServiceAPI) ifNotEmpty: [ 
		:exceptionsName | 
		self <<< ' throws '.
		exceptionsName
			do: [ :exceptionName | self <<< exceptionName ]
			separatedBy: [ self <<< ', ' ] ].

	"Printing body of method if class is not abstract or an interface"
	currentStream
		<< ' {';
		<< String crlf.
	self indentPlus.
	self printConvertParametersOf: aServiceAPI.
	self << aMethod bodySourceText.
	"aMethod methodsOverriding
		ifNotEmpty: [ :methods | 
			methods
				do: [ :methodOverriding | self << methodOverriding bodySourceText ]
				separatedBy: [ self crlf ] ]
		ifEmpty: [ self << '// Error body not found ' ]"
	self
		indentMinus;
		crlf;
		<< '}'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitServiceAPIParameter: parameter [
	"not use anymore"
	"parameter dataType isDictionaryType
		ifTrue: [ self <<< 'String ' <<< parameter name ]
		ifFalse: [ parameter dataType isCollectionType
				ifTrue: [ self <<< 'List<FormDataBodyPart> ' <<< parameter name ]
				ifFalse: [ (parameter dataType isBusinessType or: [ parameter dataType isPrimitive not ])
						ifTrue: [ self <<< 'FormDataBodyPart ' <<< parameter name ]
						ifFalse: [ self visitParameter: parameter source ] ] ].
	parameter dataType isPrimitive not ifTrue: [ self <<< 'Json' ]"
]
