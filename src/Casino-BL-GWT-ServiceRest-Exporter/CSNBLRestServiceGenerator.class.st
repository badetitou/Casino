"
```
restServiceExporter := CSNBLRestServiceGenerator new.
restServiceExporter rootFolder: ('my/root/fr/local/package/path' asFileReference).
restServiceExporter rootNamespace: 'fr/local/package/path'.
gwtModel allCSNService do: [ :service | restServiceExporter service: service; export ].
```
"
Class {
	#name : #CSNBLRestServiceGenerator,
	#superclass : #FAMIX2JavaVisitor,
	#instVars : [
		'service',
		'rootNamespace',
		'isJersey',
		'withoutPrefix',
		'withPrefix'
	],
	#category : #'Casino-BL-GWT-ServiceRest-Exporter'
}

{ #category : #actions }
CSNBLRestServiceGenerator class >> export: service [
	self new service: service; export
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAnnotation [

	currentStream
		<< '@Component';
		crlf;
		<< '@ApplicationPath("/rest-csn")';
		crlf.
	(currentStream << '@Path("' << service targetPoint)
		<< '")';
		crlf
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAnnotationForServiceAPI: aServiceAPI [
	(self << '@Path("' <<< aServiceAPI uniqueName)
		<<< '")';
		crlf.
	self addRESTTypeAnnotationFor: aServiceAPI.
	self
		<< '@Produces(MediaType.APPLICATION_JSON)';
		crlf.
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addAuthors [
	self
		<< '/**';
		crlf;
		<< ' * Generated by Casino';
		crlf;
		<< '**/'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> addRESTTypeAnnotationFor: aServiceAPI [

	"aServiceAPI isDELETE
		ifTrue: [ self << ''@POST'' ]
		ifFalse: [ aServiceAPI isGET
				ifTrue: [ self << ''@GET'' ]
				ifFalse: [ self << ''@POST'' ] ]."

	self << '@POST'.
	self crlf
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> additionalExceptionFor: aServiceAPI [

	^ { 'JsonProcessingException' } "(aServiceAPI parameters anySatisfy: [ :parameter | parameter dataType isDictionaryType ])
		ifTrue: [ {'JsonParseException' . 'JsonMappingException' . 'IOException'} ]
		ifFalse: [ {} ]"
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> beForJersey [
	self isJersey: true
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertBusinessType: serviceParameter [

	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	serviceParameter source declaredType
		ifNotNil: [ 
			self << serviceParameter source declaredType name <<< ' '
			<<< serviceParameter name <<< ' = '
			<<< 'CSNRestful.MAPPER.treeToValue(body.get("'
			<<< serviceParameter name <<< '"), '
			<<< serviceParameter source declaredType name <<< '.class);' ]
		ifNil: [ self << '// FIX: ' <<< serviceParameter name ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertCollectionType: serviceParameter [

	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	self indent.
	self printDeclaredType: serviceParameter source declaredType.
	self <<< ' ' <<< serviceParameter name
	<<< ' = CSNRestful.MAPPER.treeToValue(body.get("'
	<<< serviceParameter name <<< '"), '.
	self <<< (serviceParameter source declaredType name = 'List'
		 ifTrue: [ 'ArrayList' ]
		 ifFalse: [ serviceParameter source declaredType name ]).
	self <<< '.class);'
]

{ #category : #convert }
CSNBLRestServiceGenerator >> convertDictionaryType: serviceParameter [

	(self << '// Convert ')
		<<< serviceParameter name;
		crlf.
	self indent.
	serviceParameter dataType writeJavaBusinessTypeOn: self.
	self <<< ' ' <<< serviceParameter name
	<<< ' = CSNRestful.MAPPER.treeToValue(body.get("'
	<<< serviceParameter name <<< '"), '.
	self <<< serviceParameter source declaredType name.
	self <<< '.class);'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> createNamespaceFolderForClass: class [
	self visitNamespace: (class atScope: FamixTPackage) anyOne
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> defaultRootNamespace [
	^ 'fr/bl/server/omaje/ws/rest'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> export [
	| exporter |
	exporter := self clone.
	self rootFolder ensureCreateDirectory.
	service ifNil: [ self error ].
	service source ifNotNil: [ :source | exporter createNamespaceFolderForClass: source ].
	service source accept: exporter
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> exportedClassNameOf: aClass [

	^ withPrefix , (aClass name removePrefix: withoutPrefix)
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> extractDeclaredTypesFor: aClass [

	| declaredTypes |
	declaredTypes := super extractDeclaredTypesFor: aClass.
	declaredTypes addAll: (service actions collect: [ :action | 
			 action dependencies collect: #source ]) flattened.
	service actions do: [ :action | 
		action parameters do: [ :parameter | 
			parameter dataType isDictionaryType ifTrue: [ 
				declaredTypes add:
					(aClass mooseModel allParameterizableClasses detect: [ :c | 
						 c name = 'Map' ]) ] ] ].
	(Smalltalk includesKey: #FamixJavaInterface)
		ifTrue: [ 
			aClass interfaceImplementations ifNotEmpty: [ :interfaces | 
				declaredTypes add: interfaces anyOne interface ] ]
		ifFalse: [ 
			aClass superclassHierarchy
				select: #isInterface
				thenDo: [ :interface | declaredTypes add: interface  ] ].
	^ declaredTypes
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> initialize [
	super initialize.
	self rootFolder: FileSystem disk workingDirectory asFileReference / self rootNamespace.
	isJersey := false.
	withoutPrefix := ''.
	withPrefix := ''
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> isJersey [

	^ isJersey
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> isJersey: anObject [

	isJersey := anObject
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAPIParameterFor: aServiceAPI [

	self isJersey
		ifTrue: [ "self <<< '@DefaultValue(""**"") @QueryParam(""fieldNames[]"") String[] fieldNames,'"
			 ]
		ifFalse: [ 
			self
			<<<
			'@RequestParam(value="fieldNames[]", required = false) String[] fieldNames,'.
			self crlf.
			self
				indentPlus;
				indent ].
	self <<< '@RequestBody ObjectNode body'.
	self isJersey ifFalse: [ self indentMinus ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAdditionalExceptionFor: aServiceAPI [
	(aServiceAPI parameters anySatisfy: [ :parameter | parameter dataType isDictionaryType ])
		ifTrue: [ self <<< ', JsonParseException, JsonMappingException, IOException' ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAdditionalMethodsFor: aClass [

	"can be override to add additional methods"

	((aClass methods difference: (service actions collect: #source)) 
		 reject: #isConstructor)
		do: [ :otherMethod | otherMethod accept: self ]
		separatedBy: [ 
			self
				crlf;
				crlf ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printAttributeOf: aMethod ofServiceApi: aServiceAPI [

	(aServiceAPI parameters sorted: [ :p :p2 | 
		 p source sourceAnchor startPos < p2 source sourceAnchor startPos ])
		do: [ :parameter | 
			aServiceAPI isGET
				ifTrue: [ 
				self <<< '@QueryParam("' <<< (PharoStringCaseFormater on: parameter name) asKebabCase  <<< '") ' ]
				ifFalse: [ 
					self <<< '@FormDataParam("' <<< (PharoStringCaseFormater on: parameter name) asKebabCase
					<<< '") ' ].
			self visitServiceAPIParameter: parameter ]
		separatedBy: [ self <<< ', ' ]
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printCommentsFor: aMethod [

	aMethod comments do: [ :comment | 
		self << comment sourceText.
		self crlf ]
]

{ #category : #convert }
CSNBLRestServiceGenerator >> printConvertParametersOf: aServiceAPI [

	self crlf.
	aServiceAPI parameters do: [ :serviceParameter | 
		serviceParameter dataType isCollectionType
			ifTrue: [ self convertCollectionType: serviceParameter ]
			ifFalse: [ 
				serviceParameter dataType isDictionaryType
					ifTrue: [ self convertDictionaryType: serviceParameter ]
					ifFalse: [ self convertBusinessType: serviceParameter ] ].
		self crlf ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> printDefaultImport [

	"can be override"
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printFactoryMethod [

	| interfaceName |
	interfaceName := (Smalltalk includesKey: #FamixJavaInterface)
		                 ifTrue: [ 
			                 service source interfaceImplementations
				                 ifEmpty: [ service source name ]
				                 ifNotEmpty: [ :interfaces | 
				                 interfaces anyOne interface name ] ]
		                 ifFalse: [ 
			                 (service source superclassHierarchy select:
				                  #isInterface)
				                 ifEmpty: [ service source name ]
				                 ifNotEmpty: [ :interfaces | 
				                 interfaces anyOne name ] ].

	self
		<< 'private ';
		<<< interfaceName;
		<<< ' create() {';
		crlf;
		indentPlus;
		<<
			'return ContextLoader.getCurrentWebApplicationContext().getBean("';
		<<< service source name uncapitalized;
		<<< '", ';
		<<< interfaceName;
		<<< '.class);';
		indentMinus;
		crlf;
		<< $}
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printImports: aClass [

	| declaredTypes annotationTypes |
	declaredTypes := (self extractDeclaredTypesFor: aClass) asSet.
	aClass subclassHierarchyGroup do: [ :subClass | 
		declaredTypes addAll: (self extractDeclaredTypesFor: subClass) ].
	service parentService ifNotNil: [ :aParentService | 
		declaredTypes add: aParentService source ].
	self printImportsDeclaredTypes: declaredTypes asSet.
	"fetching annotation imports"
	self
		crlf;
		<< '// Annotation import';
		crlf.
	annotationTypes := (self extractAnnotationTypesFor: aClass) asSet.
	aClass subclassHierarchyGroup do: [ :subClass | 
		annotationTypes addAll: (self extractAnnotationTypesFor: subClass) ].
	self printImportsAnnotationTypes: annotationTypes.
	"default import"
	self
		crlf;
		<< '// Default import';
		crlf.

	self
		<< 'import java.util.ArrayList;';
		crlf.
	self printDefaultImport
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printMethodAnnotations: aMethod [

	aMethod annotationInstances
		reject: [ :annotationInstance | 
			annotationInstance annotationType name = 'Override' ]
		thenDo: [ :annotationInstance | 
			self clone visit: annotationInstance.
			self eol ]
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printMethodBodyFor: aServiceAPI [

	| interfaceName instName |
	interfaceName := (Smalltalk includesKey: #FamixJavaInterface)
		                 ifTrue: [ 
			                 service source interfaceImplementations
				                 ifEmpty: [ service source name ]
				                 ifNotEmpty: [ :interfaces | 
				                 interfaces anyOne interface name ] ]
		                 ifFalse: [ 
			                 (service source superclassHierarchy select:
				                  #isInterface)
				                 ifEmpty: [ service source name ]
				                 ifNotEmpty: [ :interfaces | 
				                 interfaces anyOne name ] ].
	instName := service targetPoint uncapitalized , 'Impl'.
	self << 'final ' <<< interfaceName <<< ' ' <<< instName
	<<< ' = this.create();'.
	self crlf.
	aServiceAPI source declaredType name = 'void'
		ifTrue: [ self indent ]
		ifFalse: [ 
			self << 'return '
			"	(aServiceAPI dataType isNil or: [ aServiceAPI dataType isPrimitive ]) 
				ifFalse: [ self <<< 'new BLFilterMappingJacksonValue<>(' ]" ].
	self <<< instName <<< $. <<< aServiceAPI name <<< $(.
	aServiceAPI sortedParameters
		do: [ :serviceParameter | self <<< serviceParameter name ]
		separatedBy: [ self <<< ', ' ].
	aServiceAPI source declaredType name = 'void'
		ifTrue: [ self <<< ');' ]
		ifFalse: [ "(aServiceAPI dataType isNil or: [ aServiceAPI dataType isPrimitive ]) 
				ifFalse: [ self <<< '), fieldNames' ]." 
			self <<< ');' ]
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printModifiersFor: aMethod [

	"Turns out we only ever need to put the method's visibility, which is always public (even if Famix doesn't think so) ."

	self << 'public'

	"Old code was"
	"
(aMethod cacheAt: #modifiers ifAbsent: [ 
		 (aMethod respondsTo: #modifiers)
			 ifTrue: [ aMethod modifiers ]
			 ifFalse: [ {  } ] ])
		ifNotEmptyDo: [ :modifier | 
			self
				<<< modifier;
				space ]
		ifEmpty: [ 
			self
				<<< 'public';
				space ]."
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printNameAndParametersFor: aServiceAPI [

	| aMethod |
	"Printing name + parameters of method"
	aMethod := aServiceAPI source.
	(aMethod name = '<Initializer>' or: [ 
		 aMethod isInitializer and: [ aMethod isConstructor not ] ])
		ifFalse: [ 
			self
				<<< aServiceAPI uniqueName;
				<<< '('.
			self printAPIParameterFor: aServiceAPI.
			"self printAttributeOf: aMethod ofServiceApi: aServiceAPI."
			self <<< ')' ]
		ifTrue: [ self << 'static' ].
	"print exception"
	(((aMethod withMethodsOverriding collect: [ :m | 
		   m thrownExceptions , m declaredExceptions]) flattened asSet asOrderedCollection sorted:
		  #name ascending) collect: #name)
	, (self additionalExceptionFor: aServiceAPI) ifNotEmpty: [ 
		:exceptionsName | 
		self <<< ' throws '.
		exceptionsName
			do: [ :exceptionName | self <<< exceptionName ]
			separatedBy: [ self <<< ', ' ] ]
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printRESTImports [

	self << 'import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.DELETE;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.ApplicationPath;'.
	self isJersey ifTrue: [ 
		"self
			<< 'import javax.ws.rs.QueryParam;';
			crlf;
			<< 'import javax.ws.rs.DefaultValue;'" ].
		self crlf.
	self << 'import fr.bl.rest.casino.CSNRestful;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;'.
	self isJersey ifFalse: [ 
		self
		<< 'import org.springframework.web.bind.annotation.RequestParam;' ].

	self << 'import org.springframework.stereotype.Component;
import org.springframework.web.context.ContextLoader;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;
'
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printReturnTypeFor: aServiceAPI [

	"Because Famix can't modelize arrays, we have to hack the declared type out of the source text."

	| start end method |
	method := aServiceAPI source.
	start := method sourceText findString: method declaredType name.
	end := method sourceText
		       findString: method name
		       startingAt: start + method declaredType name size + 1.
"	(aServiceAPI dataType isNil or: [ aServiceAPI dataType isPrimitive ]) 
		ifFalse: [ self <<< 'BLFilterMappingJacksonValue<' ]."

	self <<< (method sourceText copyFrom: start to: end - 1) trim.
	"(aServiceAPI dataType isNil or: [ aServiceAPI dataType isPrimitive ]) 
		ifFalse: [ self <<< '>' ]"
]

{ #category : #printing }
CSNBLRestServiceGenerator >> printSetterOf: aAttribute [

	self << 'public void set' <<< aAttribute name capitalized <<< ' ('.
	self printDeclaredType: aAttribute declaredType.
	(self <<< ' ' <<< aAttribute name)
		<<< ') {';
		crlf.
	self
		indentPlus;
		indent.
	(self <<< 'this.' <<< aAttribute name <<< ' = ' <<< aAttribute name)
		<<< ';';
		crlf.
	self
		indentMinus;
		<< '}'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> reset [
	super reset.
	self initialize
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> rootNamespace [
	^ rootNamespace ifNil: [ rootNamespace := self defaultRootNamespace ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> rootNamespace: aNamespace [
	rootNamespace := aNamespace
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> service: aService [
	service := aService 
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitAttribute: aAttribute [

	((aAttribute annotationInstances anySatisfy: [ :ann | 
		  ann name beginsWith: '@Autowired' ]) or: [ 
		 aAttribute declaredType isNil or: [ 
			 aAttribute declaredType isPrimitiveType or: [ aAttribute isClassSide ] ] ]) 
		ifFalse: [ 
			self
				<< '@Autowired';
				crlf ].
	super visitAttribute: aAttribute
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitClass: aClass [

	| file |
	file := self rootFolder
	        / ((self exportedClassNameOf: aClass) , '.java').
	file deleteIfAbsent: [  ].
	file writeStreamDo: [ :stream | 
		currentStream := stream.
		"Printing class package and imports if the class is not an inner class"
		aClass typeContainer isPackage ifTrue: [ 
			self << 'package '.
			aClass typeContainer
				fullNameLowerCasePrintOn: currentStream
				fromRoot: ((self rootNamespace copyReplaceAll: '/' with: '.')
						 copyReplaceAll: '\'
						 with: '.').
			self
				<<< ';';
				eol;
				eol.
			self printImports: aClass.
			self eol.
			self printRESTImports.
			self
				eol;
				eol ].
		"Printing class annotations"
		self addAuthors.
		self eol.
		self addAnnotation.
		"Printing Class declaration"
		currentStream << 'public '.
		currentStream << 'class '.
		currentStream << (self exportedClassNameOf: aClass).
		service parentService ifNotNil: [ :parentService | 
			self <<< ' extends ' <<< service parentService source name ].
		currentStream << ' {'.
		self eol.
		self indentPlus.
		"Printing Attributs"

		"(aClass attributes
		 , (aClass subclassHierarchyGroup collect: #attributes)) flattened 
			do: [ :attribute | 
				self clone visit: attribute.
				self
					crlf;
					crlf ]."
		self
			printFactoryMethod;
			crlf.
		"Closing Class"
		service actions
			do: [ :action | self visitServiceAPI: action ]
			separatedBy: [ 
				self
					crlf;
					crlf ].
		"self printAdditionalMethodsFor: aClass."
		currentStream
			<< String crlf;
			<< '}' ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitNamespace: aNamespace [
	aNamespace name = '<Default Package>' ifTrue: [ ^ self ].
	((aNamespace allParents reject: [ :p | p name = 'remote' ]) reverse allButFirst: 4)
		do: [ :namespace | 
			self rootFolder: self rootFolder / namespace name asLowercase.
			self rootFolder ensureCreateDirectory ].
	aNamespace name = 'remote'
		ifFalse: [ self rootFolder: self rootFolder / aNamespace name asLowercase.
			self rootFolder ensureCreateDirectory ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitPackage: aNamespace [
	aNamespace name = '<Default Package>' ifTrue: [ ^ self ].
	((aNamespace allParents reject: [ :p | p name = 'remote' ]) reverse allButFirst: 4)
		do: [ :namespace | 
			self rootFolder: self rootFolder / namespace name asLowercase.
			self rootFolder ensureCreateDirectory ].
	aNamespace name = 'remote'
		ifFalse: [ self rootFolder: self rootFolder / aNamespace name asLowercase.
			self rootFolder ensureCreateDirectory ]
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitServiceAPI: aServiceAPI [

	| aMethod |
	aServiceAPI name record.
	aMethod := aServiceAPI source.
	aMethod isStub ifTrue: [ ^ self ].
	(aMethod visibility = 'private' or: [ 
		 (aMethod respondsTo: #modifiers) and: [ 
			 aMethod modifiers includes: 'private' ] ]) ifTrue: [ ^ self ].
	"Printing method annotations"


	self crlf.
	self printCommentsFor: aMethod.
	self addAnnotationForServiceAPI: aServiceAPI.
	aServiceAPI uniqueName endsWithDigit ifTrue: [ "Probably a name of a service duplicated"
		self
			<< '// TODO: rename service path';
			eol ].
	"Printing modifiers of method ex: static,public/private/protected"
	self
		printModifiersFor: aMethod;
		space.

	self
		printReturnTypeFor: aServiceAPI;
		space.

	"Printing name + parameters of method"
	self printNameAndParametersFor: aServiceAPI.

	"Printing body of method"
	self
		<<< ' {';
		crlf;
		indentPlus;
		printConvertParametersOf: aServiceAPI;
		crlf;
		printMethodBodyFor: aServiceAPI;
		crlf;
		indentMinus;
		<< '}'
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> visitServiceAPIParameter: parameter [
	"not use anymore"
	"parameter dataType isDictionaryType
		ifTrue: [ self <<< 'String ' <<< parameter name ]
		ifFalse: [ parameter dataType isCollectionType
				ifTrue: [ self <<< 'List<FormDataBodyPart> ' <<< parameter name ]
				ifFalse: [ (parameter dataType isBusinessType or: [ parameter dataType isPrimitive not ])
						ifTrue: [ self <<< 'FormDataBodyPart ' <<< parameter name ]
						ifFalse: [ self visitParameter: parameter source ] ] ].
	parameter dataType isPrimitive not ifTrue: [ self <<< 'Json' ]"
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> withPrefix [

	^ withPrefix
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> withPrefix: anObject [

	withPrefix := anObject
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> withoutPrefix [

	^ withoutPrefix
]

{ #category : #accessing }
CSNBLRestServiceGenerator >> withoutPrefix: anObject [

	withoutPrefix := anObject
]
